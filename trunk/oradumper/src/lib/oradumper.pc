/* -*-mode: c-*- */

#if HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif

#if HAVE_STRING_H
#include <string.h>
#endif

#if HAVE_SQLCPR_H
#include <sqlcpr.h>
#endif

#if HAVE_DBUG_H
#include <dbug.h>
#endif

/* include dmalloc as last one */
#ifdef WITH_DMALLOC
#include <dmalloc.h>
#endif

#include "oradumper.h"
#include "oradumper_int.h"

/* declare a structure */
#ifdef SQLCA_NONE 
#undef SQLCA_NONE 
#endif

#ifdef SQLCA_STORAGE_CLASS
#undef SQLCA_STORAGE_CLASS
#endif

/* a static sqlca only */
#define SQLCA_STORAGE_CLASS static

/* force initialisation of the static sqlca struct */
#ifndef SQLCA_INIT
#define SQLCA_INIT
#endif

EXEC SQL INCLUDE sqlca;

EXEC SQL BEGIN DECLARE SECTION;
const char  indesc[]="input_descriptor";                /* descriptor names       */
const char outdesc[]="output_descriptor";
#define MAX_NAME_LEN 255
EXEC SQL END DECLARE SECTION;

error_t
sql_connect(userid)
EXEC SQL BEGIN DECLARE SECTION;
const char *userid;
EXEC SQL VAR userid IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_connect");

  EXEC SQL WHENEVER SQLERROR CONTINUE;

  EXEC SQL CONNECT :userid;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_execute_immediate(statement)
EXEC SQL BEGIN DECLARE SECTION;
const char *statement;
EXEC SQL VAR statement IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_execute_immediate");
  DBUG_PRINT("input", ("statement: %s", statement));

  EXEC SQL WHENEVER SQLERROR CONTINUE;

  EXEC SQL EXECUTE IMMEDIATE :statement;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_allocate_descriptors(max_array_size)
EXEC SQL BEGIN DECLARE SECTION;
const unsigned int max_array_size;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_allocate_descriptors");
  DBUG_PRINT("input", ("max_array_size: %u", max_array_size));

  /* Allocate the input and output descriptors. */
  /* The input is only used for query bind variables hence no array processing */
  EXEC SQL
    ALLOCATE DESCRIPTOR LOCAL :indesc;
  EXEC SQL FOR :max_array_size
    ALLOCATE DESCRIPTOR LOCAL :outdesc;
      
  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_parse(select_statement)
EXEC SQL BEGIN DECLARE SECTION;
const char *select_statement;
EXEC SQL VAR select_statement IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_parse");
  DBUG_PRINT("input", ("select_statement: %s", select_statement));

  /* Prepare the statement and declare a cursor. */
  EXEC SQL PREPARE S FROM :select_statement;
  EXEC SQL DECLARE C CURSOR FOR S;
  EXEC SQL DESCRIBE INPUT S USING DESCRIPTOR LOCAL :indesc;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_bind_variable_count(count)
EXEC SQL BEGIN DECLARE SECTION;
unsigned int *count;
EXEC SQL END DECLARE SECTION;
{

  DBUG_ENTER("sql_bind_variable_count");

  EXEC SQL GET DESCRIPTOR LOCAL :indesc :count = COUNT; 

  DBUG_PRINT("output", ("count: %u; return: %d", *count, sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_bind_variable_name(nr, size, name)
EXEC SQL BEGIN DECLARE SECTION;
unsigned int nr;
char *name;
EXEC SQL END DECLARE SECTION;
const size_t size;
{
  EXEC SQL BEGIN DECLARE SECTION;
  char bind_variable_name[MAX_NAME_LEN+1];
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("sql_bind_variable_name");
  DBUG_PRINT("input", ("nr: %u; size: %d", nr, (int) size));

  EXEC SQL GET DESCRIPTOR LOCAL :indesc
    VALUE :nr :bind_variable_name = NAME;

  (void) strncpy(name, bind_variable_name, size - 1);
  name[size - 1] = '\0';

  DBUG_PRINT("output", ("name: %s; return: %d", name, sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_bind_variable(nr, value)
EXEC SQL BEGIN DECLARE SECTION;
unsigned int nr;
const char *value;
EXEC SQL END DECLARE SECTION;
{
  EXEC SQL BEGIN DECLARE SECTION;
  const int type = ANSI_CHARACTER_VARYING;
  const short ind = (value == NULL ? -1 : 0);
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("sql_bind_variable_name");
  DBUG_PRINT("input", ("nr: %u; value: %s", nr, value));

  EXEC SQL SET DESCRIPTOR LOCAL :indesc
    VALUE :nr TYPE = :type, DATA = :value, INDICATOR = :ind;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_open_cursor(void)
{
  DBUG_ENTER("sql_open_cursor");

  /* Open the cursor and execute the statement. */
  EXEC SQL
    OPEN C USING DESCRIPTOR LOCAL :indesc;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_column_count(count)
EXEC SQL BEGIN DECLARE SECTION;
unsigned int *count;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_column_count");

  EXEC SQL DESCRIBE OUTPUT S USING DESCRIPTOR LOCAL :outdesc;
   
  EXEC SQL GET DESCRIPTOR LOCAL :outdesc :count = COUNT;

  DBUG_PRINT("output", ("count: %u; return: %d", *count, sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_describe_column(nr, size, name, type, length)
EXEC SQL BEGIN DECLARE SECTION;
const unsigned int nr;
char *name;
int *type;
unsigned int *length;
EXEC SQL END DECLARE SECTION;
const size_t size;
{
  EXEC SQL BEGIN DECLARE SECTION;
  char column_name[MAX_NAME_LEN+1];
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("sql_describe_column");
  DBUG_PRINT("input", ("nr: %u; size: %d", nr, (int) size));

  EXEC SQL GET DESCRIPTOR LOCAL :outdesc VALUE :nr
    :type = TYPE, :column_name = NAME, :length = OCTET_LENGTH;

  (void) strncpy(name, column_name, size - 1);
  name[size - 1] = '\0';

  DBUG_PRINT("output", ("name: %s; type: %d; length: %u; return: %d", name, *type, *length, sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_define_column(nr, type, length, array_size, data, ind)
EXEC SQL BEGIN DECLARE SECTION;
const unsigned int nr;
const int type;
const unsigned int length;
const unsigned int array_size;
const char **data;
const short *ind;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_define_column");
  DBUG_PRINT("input",
	     ("nr: %u; type: %d; length: %u; array_size: %u",
	      nr,
	      type,
	      length,
	      array_size));

  EXEC SQL SET DESCRIPTOR LOCAL :outdesc VALUE :nr
    TYPE = :type, LENGTH = :length;
   
  EXEC SQL FOR :array_size
    SET DESCRIPTOR LOCAL :outdesc VALUE :nr
    REF DATA = :data, REF INDICATOR = :ind;

  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_fetch_rows(array_size, count)
EXEC SQL BEGIN DECLARE SECTION;
const unsigned int array_size;
EXEC SQL END DECLARE SECTION;
unsigned int *count;
{
  DBUG_ENTER("sql_fetch_rows");
  DBUG_PRINT("input", ("array_size: %u", array_size));

  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL FOR :array_size 
    FETCH C INTO DESCRIPTOR LOCAL :outdesc;

  *count = sqlca.sqlerrd[2] - *count;

  /* SQLCODE 100 IS NO DATA FOUND */
  if (sqlca.sqlcode == 100)
    sqlca.sqlcode = 0;

  DBUG_PRINT("output", ("count: %u; return: %d", *count, sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_rows_processed(unsigned int *count)
{
  *count = sqlca.sqlerrd[2];

  return sqlca.sqlcode;
}

error_t
sql_close_cursor(void)
{
  DBUG_ENTER("sql_close_cursor");

  EXEC SQL CLOSE C;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_deallocate_descriptors(void)
{
  DBUG_ENTER("sql_deallocate_descriptors");

  /* Deallocate the descriptors */
  EXEC SQL DEALLOCATE DESCRIPTOR LOCAL :indesc;
  EXEC SQL DEALLOCATE DESCRIPTOR LOCAL :outdesc;
      
  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

void
sql_error(unsigned int *length, char **msg)
{
  *length = (unsigned int) sqlca.sqlerrm.sqlerrml;
  *msg = (char *) sqlca.sqlerrm.sqlerrmc;
}
