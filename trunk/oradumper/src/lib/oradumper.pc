/* -*-mode: c-*- */

/*@-fullinitblock@*/
/*@+matchanyintegral@*/
/*@-initallelements@*/
/*@-type@*/
/*@-shadow@*/
/*@-immediatetrans@*/
/*@-statictrans@*/
/*@-nullpass@*/
/*@-compdef@*/
/*@-compdestroy@*/
/*@-observertrans@*/
/*@-unqualifiedtrans@*/
/*@-nullstate@*/
/*@-nullderef@*/
/*@-globstate@*/
/*@-initallelements@*/
/*@-dependenttrans@*/
/*@-usedef@*/
/*@-varuse@*/

#if HAVE_CONFIG_H
#include <config.h>
#endif

/* skip irrelevant includes during PRO*C precompilation */
#ifndef ORA_PROC

/* defined on any system */
#include <stdio.h>

#if HAVE_ASSERT_H
#include <assert.h>
#endif

#if HAVE_CTYPE_H
#include <ctype.h>
#endif

#if HAVE_MALLOC_H
#include <malloc.h>
#endif

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif

#if HAVE_STRING_H
#include <string.h>
#endif

#if HAVE_STRINGS_H
#include <strings.h>
#endif

#endif

/* declare a structure */
#ifdef SQLCA_NONE 
#undef SQLCA_NONE 
#endif

#ifdef SQLCA_STORAGE_CLASS
#undef SQLCA_STORAGE_CLASS
#endif

/* a static sqlca only */
#define SQLCA_STORAGE_CLASS static

/* force initialisation of the static sqlca struct */
#ifndef SQLCA_INIT
#define SQLCA_INIT
#endif

#if HAVE_SQLCPR_H
#include <sqlcpr.h>
#endif

EXEC SQL INCLUDE sqlca;

/* skip irrelevant includes during PRO*C precompilation */
#ifndef ORA_PROC
#include <dbug.h>
#endif

#include "oradumper_int.h"

/* include dmalloc as last one */
#ifdef WITH_DMALLOC
#include "dmalloc.h"
#endif

#define MAX_VNAME_LEN     30
#define MAX_INAME_LEN     30

#define vstrcpy( a, b ) \
  (strcpy( (char*)a.arr, b ), a.len = strlen( (char*)a.arr ), a.arr)

/*EXEC SQL INCLUDE sqlca;*/
EXEC SQL INCLUDE sqlda;

static
void
die( char * msg )
{
  (void) fprintf( stderr, "%s\n", msg );
  exit(EXIT_FAILURE);
}

/*
    this array contains a default mapping
    I am using to constrain the
       lengths of returned columns.  It is mapping,
    for example, the Oracle
       NUMBER type (type code = 2) to be 45 characters
    long in a string.
*/

static
int
lengths[] =
{ -1, 0, 45, 0, 0, 0, 0, 0, 2000, 0, 0,
 18, 25, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 512, 2000 };

static
void
sqlerror_hard()
{
  EXEC SQL WHENEVER SQLERROR CONTINUE;

  (void) fprintf(stderr,"\nORACLE error detected:");
  (void) fprintf(stderr,"\n% .70s \n", sqlca.sqlerrm.sqlerrmc);

  EXEC SQL ROLLBACK WORK RELEASE;

  exit(EXIT_FAILURE);
}

static
void
process(sqlstmt, array_size)
EXEC SQL BEGIN DECLARE SECTION;
char *sqlstmt;
int array_size;
EXEC SQL END DECLARE SECTION;
{
  SQLDA *select_dp;
  int i;
  int j;
  int null_ok;
  int size = 10;
  int last_fetch_count;
  int row_count = 0;
  short ind_value;
  char *char_ptr;

  (void) fprintf( stderr, "Unloading '%s'\n", sqlstmt );
  (void) fprintf( stderr, "Array size = %d\n", array_size );

  EXEC SQL WHENEVER SQLERROR DO sqlerror_hard();
  EXEC SQL PREPARE S FROM :sqlstmt;
  EXEC SQL DECLARE C CURSOR FOR S;

  if ((select_dp = sqlald(size,MAX_VNAME_LEN,MAX_INAME_LEN))
      == NULL )
    {
      die( "Cannot allocate  memory for select descriptor." );
    }

  select_dp->N = size;

  EXEC SQL DESCRIBE SELECT LIST FOR S INTO select_dp;

  if ( select_dp->F == 0 )
    {
      return;
    }
  
  if (select_dp->F < 0)
    {
      size = -select_dp->F;
      sqlclu( select_dp );
      if ((select_dp =
	   sqlald (size, MAX_VNAME_LEN, MAX_INAME_LEN))
	  == NULL )
	{
	  die( "Cannot allocate  memory for descriptor." );
	}

      EXEC SQL DESCRIBE SELECT LIST FOR S INTO select_dp;
    }

  select_dp->N = select_dp->F;

  for (i = 0; i < select_dp->N; i++)
    {
      select_dp->I[i] = (short *) malloc(sizeof(short) *
					 array_size );
    }

  for (i = 0; i < select_dp->F; i++)
    {
      sqlnul ((unsigned short*)&(select_dp->T[i]),
	      (unsigned short*)&(select_dp->T[i]), &null_ok);
      if ( select_dp->T[i] <
	   sizeof(lengths)/sizeof(lengths[0]) )
        {
	  if ( lengths[select_dp->T[i]] != 0 )
	    {
	      select_dp->L[i]  = lengths[select_dp->T[i]];
	    }
	  else
	    {
	      select_dp->L[i] += 5;
	    }
        }
      else
	{
	  select_dp->L[i] += 5;
	}

      select_dp->T[i] = 5;
      select_dp->V[i] = (char *)malloc( select_dp->L[i] *
					array_size );

      for( j = MAX_VNAME_LEN-1;
	   j > 0 && select_dp->S[i][j] == ' ';
	   j--) 
	{ 
	  ;
	}

      (void) fprintf(stderr,
		     "%s%.*s", (i!=0?",":""), j+1, select_dp->S[i]);
    }
  (void) fprintf( stderr, "\n" );

  EXEC SQL OPEN C;

  for ( last_fetch_count = 0;
	;
	last_fetch_count = sqlca.sqlerrd[2] )
    {
      EXEC SQL FOR :array_size FETCH C
	USING DESCRIPTOR select_dp;

      for (j = 0; j < sqlca.sqlerrd[2]-last_fetch_count; j++)
        {
	  for (i = 0; i < select_dp->F; i++)
            {
	      ind_value = *(select_dp->I[i]+j);
	      char_ptr  = select_dp->V[i] + (j*select_dp->L[i]);

	      (void) printf( "%s%s", (i!=0?",":""),
			     (ind_value != 0?"(null)":char_ptr) );
            }

	  row_count++;
	  (void) putchar( '\n' );
        }

      if ( sqlca.sqlcode > 0 )
	{
	  break;
	}
    }

  sqlclu(select_dp);

  EXEC SQL CLOSE C;

  EXEC SQL COMMIT WORK;

  (void) fprintf( stderr, "%d rows extracted\n", row_count );
}

int
oradumper(const unsigned int length, const char **options)
{
  EXEC SQL BEGIN DECLARE SECTION;
  VARCHAR oracleid[50];
  EXEC SQL END DECLARE SECTION;

  process_options(length, options);

  /* Connect to ORACLE. */
  vstrcpy( oracleid, get_option(OPTION_USERID) );

  EXEC SQL WHENEVER SQLERROR DO sqlerror_hard();

  EXEC SQL CONNECT :oracleid;
  (void) fprintf(stderr, "\nConnected to ORACLE as user: %s\n\n",
		 (char*)oracleid.arr);

  EXEC SQL ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH24:MI:SS';

  process( get_option(OPTION_SQLSTMT), atoi(get_option(OPTION_ARRAYSIZE)) );

  /* Disconnect from ORACLE. */
  EXEC SQL COMMIT WORK RELEASE;

  return 0;
}

#if 0
set_bind_variables(char * bindValues[] )
{
  int size = 10;
  int i;
  char bvname[255];
  SQLDA *bind_dp;
                                                                                                    
  if ((bind_dp = sqlald(size, 255, 255)) == NULL)
    die( "Cannot allocate memory for bind descriptor" );
          
  bind_dp->N = size;
  EXEC SQL DESCRIBE BIND VARIABLES FOR S INTO bind_dp;

  if ( sqlca.sqlcode ) return sqlerror_soft(__LINE__);
          
  if (bind_dp->F < 0)
    {
      size = -bind_dp->F;
      sqlclu(bind_dp);
      if ((bind_dp = sqlald(size, 255, 255)) == NULL)
	{
	  die( "Cannot allocate memory for bind descriptor" );
	}
                                                                                                    
      bind_dp->N = size;  /* Initialize count of array elements. */
      EXEC SQL DESCRIBE BIND VARIABLES FOR S INTO bind_dp;
      if ( sqlca.sqlcode ) 
	{
	  return sqlerror_soft(__LINE__);
	}
    }
                                                                                                    
  bind_dp->N = bind_dp->F;
  for (i = 0; i < bind_dp->N; i++)
    {
      bind_dp->I[i] = (short *) malloc(sizeof (short));
    }
          
  for (i = 0; i < bind_dp->F; i++)
    {
      bind_dp->V[i] = bindValues[i];
      bind_dp->L[i] = strlen(bind_dp->V[i]);
      *bind_dp->I[i] = (*bind_dp->V[i]) ? 0 : -1;
      if ( *bind_dp->I[i] )
        {
	  bind_dp->V[i] = (char *)malloc(5);
	  bind_dp->L[i] = 4;
        }
      bind_dp->T[i] = 1;
    }
  EXEC SQL OPEN C USING DESCRIPTOR bind_dp;
  if ( sqlca.sqlcode )
    {
      return sqlerror_soft(__LINE__);
    }
          
  for ( i = 0; i < bind_dp->N; i++ )
    {
      free( bind_dp->I[i] );
    }
  sqlclu( bind_dp );
}
#endif
