/* -*-mode: c-*- */
/*******************************************************************
ANSI Dynamic Demo 2:  ANSI Dynamic SQL with reference semantics,
                           batch processing and local descriptor
                           names in host variables
                           
This program demonstates using ANSI Dynamic SQL to process SQL
statements which are not known until runtime.  It uses the Oracle
extensions for batch processing and reference semantics.

The program connects you to ORACLE using your username and password,
then prompts you for a SQL statement.  Enter legal SQL or PL/SQL 
statement using interactive, not embedded, SQL syntax, terminating the 
statement with a seimcolon.  Your statement will be processed.  If it
is a query, the fetched rows are displayed. 

If your statement has input bind variables (other than in a where clause),
the program will ask for an input array size and then allow you to enter 
that number of input values. If your statment has output, the program will
ask you for an output array size and will do array fetchng using that value.
It will also output the rows fetched in one batch together, so using a small
value for the output array size will improve the look of the output.  
For example, connected as scott/tiger, try select empno, ename from emp
with an output array size of 4;

You can enter multi-line statements.  The limit is 1023 characters.
There is a limit on the size of the variables, MAX_VAR_LEN, defined as 255.
This program processes up to 40 bind variables and 40 select-list items.

Precompile with program with dynamic=ansi, i.e:
 
proc dynamic=ansi ansidyn2

*******************************************************************/

#if HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif

#if HAVE_STRING_H
#include <string.h>
#endif

#if HAVE_SQLCPR_H
#include <sqlcpr.h>
#endif

#if HAVE_DBUG_H
#include <dbug.h>
#endif

#include "oradumper.h"
#include "oradumper_int.h"

#ifndef NULL
#define NULL  0
#endif

/* Prototypes */
static void sql_error(void);
static int oracle_connect(void);
static int process_input(void);
static int process_output(void);
static void process_data(const int output_count, int *rows_this_fetch, int *cumulative_rows);
static void rows_processed(const char *select_statement);

EXEC SQL INCLUDE sqlca;

EXEC SQL BEGIN DECLARE SECTION;
#define MAX_OCCURENCES  40
#define MAX_ARRSZ      100
#define MAX_VAR_LEN    255
#define MAX_NAME_LEN    31

char  indesc[]="input_descriptor";                /* descriptor names       */
char outdesc[]="output_descriptor";
char   input[MAX_OCCURENCES][MAX_VAR_LEN +1 ],    /* data areas */
      output[MAX_OCCURENCES][MAX_ARRSZ][MAX_VAR_LEN + 1];

short outindi[MAX_OCCURENCES][MAX_ARRSZ];        /* output indicators      */
short *iptr;

const int max_array_size = MAX_ARRSZ;   /* maximum arrays size used for allocates */
const int out_array_size = MAX_ARRSZ;          /* size of output batch, i.e., number of rows */
EXEC SQL END DECLARE SECTION;

char *dml_commands[] = {"SELECT", "select"};

int cursor_open = 0;

/* A global flag for the error routine. */
int parse_flag = 0;

error_t
sql_connect(userid)
EXEC SQL BEGIN DECLARE SECTION;
const char *userid;
EXEC SQL VAR userid IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_connect");

  EXEC SQL WHENEVER SQLERROR CONTINUE;

  EXEC SQL CONNECT :userid;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_execute_immediate(statement)
EXEC SQL BEGIN DECLARE SECTION;
const char *statement;
EXEC SQL VAR statement IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_execute_immediate");
  DBUG_PRINT("input", ("statement: %s", statement));

  EXEC SQL WHENEVER SQLERROR CONTINUE;

  EXEC SQL EXECUTE IMMEDIATE :statement;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_allocate_descriptors(max_array_size)
EXEC SQL BEGIN DECLARE SECTION;
const unsigned int max_array_size;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_allocate_descriptors");
  DBUG_PRINT("input", ("max_array_size: %u", max_array_size));

  /* Allocate the input and output descriptors. */
  /* The input is only used for query bind variables hence no array processing */
  EXEC SQL
    ALLOCATE DESCRIPTOR LOCAL :indesc;
  EXEC SQL FOR :max_array_size
    ALLOCATE DESCRIPTOR LOCAL :outdesc;
      
  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_parse(select_statement)
EXEC SQL BEGIN DECLARE SECTION;
const char *select_statement;
EXEC SQL VAR select_statement IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_parse");
  DBUG_PRINT("input", ("select_statement: %s", select_statement));

  /* Prepare the statement and declare a cursor. */
  parse_flag = 1;     /* Set a flag for sql_error(). */
  EXEC SQL PREPARE S FROM :select_statement;
  parse_flag = 0;     /* Unset the flag. */
  EXEC SQL DECLARE C CURSOR FOR S;
  EXEC SQL DESCRIBE INPUT S USING DESCRIPTOR LOCAL :indesc;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

unsigned int
sql_bind_variable_count(void)
{
  EXEC SQL BEGIN DECLARE SECTION;
  unsigned int bind_variable_count;
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("sql_bind_variable_count");

  EXEC SQL GET DESCRIPTOR LOCAL :indesc :bind_variable_count = COUNT; 

  DBUG_PRINT("output", ("return: %d", bind_variable_count));
  DBUG_LEAVE();

  return bind_variable_count;
}

const char *
sql_bind_variable_name(nr)
EXEC SQL BEGIN DECLARE SECTION;
unsigned int nr;
EXEC SQL END DECLARE SECTION;
{
  EXEC SQL BEGIN DECLARE SECTION;
  static char name[MAX_NAME_LEN];
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("sql_bind_variable_name");
  DBUG_PRINT("input", ("nr: %u", nr));

  EXEC SQL GET DESCRIPTOR LOCAL :indesc
    VALUE :nr :name = NAME;

  DBUG_PRINT("output", ("return: %s", name));
  DBUG_LEAVE();

  return name;
}

error_t
sql_bind_variable(nr, value)
EXEC SQL BEGIN DECLARE SECTION;
unsigned int nr;
const char *value;
EXEC SQL END DECLARE SECTION;
{
  EXEC SQL BEGIN DECLARE SECTION;
  const int type = ANSI_CHARACTER_VARYING;
  const int length = MAX_VAR_LEN;
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("sql_bind_variable_name");
  DBUG_PRINT("input", ("nr: %u; value: %s", nr, value));

  EXEC SQL SET DESCRIPTOR LOCAL :indesc
    VALUE :nr TYPE = :type, LENGTH = :length, REF DATA = :value;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

/**/

static
int
process(select_statement)
EXEC SQL BEGIN DECLARE SECTION;
const char *select_statement;                      /* statement variable     */
EXEC SQL VAR select_statement IS STRING;
EXEC SQL END DECLARE SECTION;
{
  int status = 1;

  DBUG_ENTER("process");

  /* Call the function that processes the input. */
  if (process_input() != 0)
    {
      goto end_of_process;
    }

  /* Open the cursor and execute the statement. */
  EXEC SQL
    OPEN C USING DESCRIPTOR LOCAL :indesc;
  cursor_open = 1;
 
  /* Call the function that processes the output. */
  if (process_output() != 0)
    {
      goto end_of_process;
    }

  /* Tell user how many rows were processed. */
  rows_processed(select_statement);

  /* Close the cursor. */
  if (cursor_open != 0)
    {
      EXEC SQL CLOSE C;
    }

  /* Deallocate the descriptors */
  EXEC SQL DEALLOCATE DESCRIPTOR LOCAL :indesc;
  EXEC SQL DEALLOCATE DESCRIPTOR LOCAL :outdesc;
  
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL COMMIT WORK RELEASE;

  EXEC SQL WHENEVER SQLERROR DO sql_error();

  status = 0;

 end_of_process:
  DBUG_LEAVE();

  return status;
}

static
int
process_output(void)
{
  int i, j;
  EXEC SQL BEGIN DECLARE SECTION;
  int output_count, occurs;
  int type, output_len = MAX_VAR_LEN;
  char name[MAX_OCCURENCES][MAX_NAME_LEN];
  int rows_this_fetch = 0, cumulative_rows = 0;
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("process_output");

  EXEC SQL DESCRIBE OUTPUT S USING DESCRIPTOR LOCAL :outdesc;
   
  EXEC SQL GET DESCRIPTOR LOCAL :outdesc :output_count = COUNT;

  DBUG_PRINT("info", ("number of columns: %d", output_count));
  
  for (i = 0; i < output_count; i++)
    {
      occurs = i + 1;
      EXEC SQL GET DESCRIPTOR LOCAL :outdesc VALUE :occurs
	:type = TYPE, :name[i] = NAME;

      DBUG_PRINT("info", ("column %d has name %s and type %d", occurs, name[i], type));

      type = ORA_STRING; /* force all data to be null terminated character */
      EXEC SQL SET DESCRIPTOR LOCAL :outdesc VALUE :occurs 
	TYPE = :type, LENGTH = :output_len;
   
      iptr = (short *)&outindi[i]; /* no mult-dimension non-char host vars */
      EXEC SQL FOR :out_array_size
	SET DESCRIPTOR LOCAL :outdesc VALUE :occurs 
	REF DATA = :output[i], REF INDICATOR = :iptr;
    }   
      
  /* print the column headings */
  for (j = 0; j < 2; j++)
    {
      for (i = 0; i < output_count; i++)
	{
	  printf("%-*.*s ", 30, 30, (j == 0 ? name[i] : "------------------------------"));
	}
      printf("\n");
    }
   
  /* FETCH each row selected and print the column values. */
  for (;;)
    {
      EXEC SQL WHENEVER NOT FOUND GOTO end_of_fetch_loop;
      EXEC SQL FOR :out_array_size 
	FETCH C INTO DESCRIPTOR LOCAL :outdesc;
      
      process_data(output_count, &rows_this_fetch, &cumulative_rows);
    }

 end_of_fetch_loop:
  process_data(output_count, &rows_this_fetch, &cumulative_rows);

  DBUG_LEAVE();

  return(0);
}

static
void
process_data(const int output_count, int *rows_this_fetch, int *cumulative_rows)
{
  int i, j;

  *rows_this_fetch = sqlca.sqlerrd[2] - *cumulative_rows;
  *cumulative_rows = sqlca.sqlerrd[2];

  DBUG_PRINT("info", ("rows fetched: %d; rows fetched cumulative: %d", *rows_this_fetch, *cumulative_rows));

  if (*rows_this_fetch != 0)
    {
      for (j = 0; j < out_array_size && j < *rows_this_fetch; j++)
	{           /* output by columns using simplified formatting */
	  for (i = 0; i < output_count; i++)
	    {                              
	      printf("%-*.*s ", 30, 30, (outindi[i][j] == -1 ? "NULL" : output[i][j]));  /* simplified */
	      /* output formatting may cause truncation */
	      /* but columns will line up */
	    }
	  printf ("\n");
	}
    }
}

static
void
rows_processed(const char *select_statement)
{  
  int i;

  DBUG_ENTER("rows_processed");

  for (i = 0; i < 8; i++)
    {
      if (strncmp(select_statement, dml_commands[i], 6) == 0)
	{
	  fprintf(stderr, "\n\n%d row%c processed.\n", sqlca.sqlerrd[2],
		 sqlca.sqlerrd[2] == 1 ? ' ' : 's');
	  break;
	}
    }

  DBUG_LEAVE();
}

static
void
sql_error()
{
  DBUG_ENTER("sql_error");

  /* ORACLE error handler */
  fprintf(stderr, "\n\n%.70s\n",sqlca.sqlerrm.sqlerrmc);
  if (parse_flag)
    fprintf
      (stderr, "Parse error at character offset %d in SQL statement.\n",
       sqlca.sqlerrd[4]);

  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL ROLLBACK WORK;

  DBUG_LEAVE();

  exit (EXIT_FAILURE);
}

static
int
oracle_connect()
{
  int status = 1;
  EXEC SQL BEGIN DECLARE SECTION;
  const char *userid = get_option(OPTION_USERID);
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("oracle_connect");

  EXEC SQL WHENEVER SQLERROR GOTO connect_error;

  EXEC SQL CONNECT :userid;

  fprintf(stderr, "\nConnected to ORACLE as %s.\n", userid);

  status = 0;
  goto end_of_oracle_connect;

 connect_error:
  fprintf(stderr, "Can not connect to ORACLE as %s.\n", userid);

 end_of_oracle_connect:

  DBUG_LEAVE();

  return status;
}

