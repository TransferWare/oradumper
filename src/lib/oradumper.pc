/* -*-mode: c-*- */
#if HAVE_CONFIG_H
#include <config.h>
#endif

/* skip irrelevant includes during PRO*C precompilation */
#ifndef ORA_PROC

/* defined on any system */
#include <stdio.h>

#if HAVE_ASSERT_H
#include <assert.h>
#endif

#if HAVE_CTYPE_H
#include <ctype.h>
#endif

#if HAVE_MALLOC_H
#include <malloc.h>
#endif

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif

#if HAVE_STRING_H
#include <string.h>
#endif

#if HAVE_STRINGS_H
#include <strings.h>
#endif

#endif

/* include sqlca.h even though it has been included already */
#ifdef SQLCA
#undef SQLCA
#endif

/* declare a structure */
#ifdef SQLCA_NONE 
#undef SQLCA_NONE 
#endif

#ifdef SQLCA_STORAGE_CLASS
#undef SQLCA_STORAGE_CLASS
#endif

/* a static sqlca only */
#define SQLCA_STORAGE_CLASS static

/* force initialisation of the static sqlca struct */
#ifndef SQLCA_INIT
#define SQLCA_INIT
#endif

EXEC SQL INCLUDE sqlca;

/* skip irrelevant includes during PRO*C precompilation */
#ifndef ORA_PROC
#include <dbug.h>
#endif

/* include dmalloc as last one */
#ifdef WITH_DMALLOC
#include "dmalloc.h"
#endif

#define MAX_VNAME_LEN     30
#define MAX_INAME_LEN     30

static char *     USERID = NULL;
static char *   SQLSTMT = NULL;
static char *   ARRAY_SIZE = "10";

#define vstrcpy( a, b ) \
  (strcpy( (char*)a.arr, b ), a.len = strlen( (char*)a.arr ), a.arr)

EXEC SQL INCLUDE sqlca;
EXEC SQL INCLUDE sqlda;

extern SQLDA *sqlald();
extern void   sqlclu();



static void die( char * msg )
{
    fprintf( stderr, "%s\n", msg );
    exit(1);
}


/*
    this array contains a default mapping
    I am using to constrain the
       lengths of returned columns.  It is mapping,
    for example, the Oracle
       NUMBER type (type code = 2) to be 45 characters
    long in a string.
*/

static int lengths[] =
{ -1, 0, 45, 0, 0, 0, 0, 0, 2000, 0, 0,
 18, 25, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 512, 2000 };


static void process_parms( argc, argv )
int    argc;
char *    argv[];
{
int    i;

    for( i = 1; i < argc; i++ )
    {
        if ( !strncmp( argv[i], "userid=", 7 ) )
              USERID = argv[i]+7;
        else
        if ( !strncmp( argv[i], "sqlstmt=", 8 ) )
              SQLSTMT = argv[i]+8;
        else
        if ( !strncmp( argv[i], "arraysize=", 10 ) )
              ARRAY_SIZE = argv[i]+10;
        else
        {
            fprintf( stderr,
                    "usage: %s %s %s\n",
                     argv[0],
                    "userid=xxx/xxx sqlstmt=query ",
                    "arraysize=<NN>\n" );
            exit(1);
        }
    }
    if ( USERID == NULL  || SQLSTMT == NULL )
    {
        fprintf( stderr,
                "usage: %s %s %s\n",
                 argv[0],
                "userid=xxx/xxx sqlstmt=query ",
                "arraysize=<NN>\n" );
        exit(1);
    }
}

static void sqlerror_hard()
{
    EXEC SQL WHENEVER SQLERROR CONTINUE;

    fprintf(stderr,"\nORACLE error detected:");
    fprintf(stderr,"\n% .70s \n", sqlca.sqlerrm.sqlerrmc);

    EXEC SQL ROLLBACK WORK RELEASE;
    exit(1);
}

static SQLDA * process_1(sqlstmt, array_size)
EXEC SQL BEGIN DECLARE SECTION;
char * sqlstmt;
EXEC SQL END DECLARE SECTION;
int array_size;
{
SQLDA *    select_dp;
int     i;
int        j;
int        null_ok;
int        precision;
int        scale;
int        size = 10;

    fprintf( stderr, "Unloading '%s'\n", sqlstmt );
    fprintf( stderr, "Array size = %d\n", array_size );


    EXEC SQL WHENEVER SQLERROR DO sqlerror_hard();
       EXEC SQL PREPARE S FROM :sqlstmt;
       EXEC SQL DECLARE C CURSOR FOR S;

    if ((select_dp = sqlald(size,MAX_VNAME_LEN,MAX_INAME_LEN))
                   == NULL )
        die( "Cannot allocate  memory for select descriptor." );

    select_dp->N = size;
    EXEC SQL DESCRIBE SELECT LIST FOR S INTO select_dp;
    if ( !select_dp->F ) return NULL;

    if (select_dp->F < 0)
    {
        size = -select_dp->F;
        sqlclu( select_dp );
        if ((select_dp =
                sqlald (size, MAX_VNAME_LEN, MAX_INAME_LEN))
                      == NULL )
        die( "Cannot allocate  memory for descriptor." );
        EXEC SQL DESCRIBE SELECT LIST FOR S INTO select_dp;
    }
    select_dp->N = select_dp->F;

    for (i = 0; i < select_dp->N; i++)
        select_dp->I[i] = (short *) malloc(sizeof(short) *
                                                array_size );

    for (i = 0; i < select_dp->F; i++)
    {
        sqlnul (&(select_dp->T[i]),
                &(select_dp->T[i]), &null_ok);
        if ( select_dp->T[i] <
                     sizeof(lengths)/sizeof(lengths[0]) )
        {
            if ( lengths[select_dp->T[i]] )
                 select_dp->L[i]  = lengths[select_dp->T[i]];
            else select_dp->L[i] += 5;
        }
        else select_dp->L[i] += 5;

        select_dp->T[i] = 5;
        select_dp->V[i] = (char *)malloc( select_dp->L[i] *
                                               array_size );

        for( j = MAX_VNAME_LEN-1;
             j > 0 && select_dp->S[i][j] == ' ';
             j--);
        fprintf (stderr,
                "%s%.*s", i?",":"", j+1, select_dp->S[i]);
    }
    fprintf( stderr, "\n" );


    EXEC SQL OPEN C;
    return select_dp;
}

static void process_2(select_dp, array_size)
SQLDA * select_dp;
EXEC SQL BEGIN DECLARE SECTION;
int array_size;
EXEC SQL END DECLARE SECTION;
{
int    last_fetch_count;
int        row_count = 0;
short    ind_value;
char    * char_ptr;
int    i,
       j;

    for ( last_fetch_count = 0;
          ;
          last_fetch_count = sqlca.sqlerrd[2] )
    {
        EXEC SQL FOR :array_size FETCH C
                      USING DESCRIPTOR select_dp;

        for( j=0; j < sqlca.sqlerrd[2]-last_fetch_count; j++ )
        {
            for (i = 0; i < select_dp->F; i++)
            {
                ind_value = *(select_dp->I[i]+j);
                char_ptr  = select_dp->V[i] +
                                  (j*select_dp->L[i]);

                printf( "%s%s", i?",":"",
                             ind_value?"(null)":char_ptr );
            }
            row_count++;
            printf( "\n" );
        }
        if ( sqlca.sqlcode > 0 ) break;
    }

    sqlclu(select_dp);

    EXEC SQL CLOSE C;

    EXEC SQL COMMIT WORK;
    fprintf( stderr, "%d rows extracted\n", row_count );
}

int oradumper( unsigned int length, char **options )
{
EXEC SQL BEGIN DECLARE SECTION;
VARCHAR   oracleid[50];
EXEC SQL END DECLARE SECTION;
SQLDA    * select_dp;


    process_parms( length, options );

    /* Connect to ORACLE. */
    vstrcpy( oracleid, USERID );

    EXEC SQL WHENEVER SQLERROR DO sqlerror_hard();

    EXEC SQL CONNECT :oracleid;
    fprintf(stderr, "\nConnected to ORACLE as user: %s\n\n",
             oracleid.arr);

    EXEC SQL ALTER SESSION
      SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH24:MI:SS';

    select_dp = process_1( SQLSTMT, atoi(ARRAY_SIZE) );
    process_2( select_dp , atoi(ARRAY_SIZE));

    /* Disconnect from ORACLE. */
    EXEC SQL COMMIT WORK RELEASE;

    return 0;
}

#if 0
set_bind_variables(char * bindValues[] )
{
int     size = 10;
int     i;
char    bvname[255];
SQLDA   * bind_dp;
                                                                                                    
          
    if ((bind_dp = sqlald(size, 255, 255)) == NULL)
        die( "Cannot allocate memory for bind descriptor" );
                                                                                                    
          
    bind_dp->N = size;
    EXEC SQL DESCRIBE BIND VARIABLES FOR S INTO bind_dp;
    if ( sqlca.sqlcode ) return sqlerror_soft(__LINE__);
                                                                                                    
          
    if (bind_dp->F < 0)
    {
        size = -bind_dp->F;
        sqlclu(bind_dp);
        if ((bind_dp = sqlald(size, 255, 255)) == NULL)
            die( "Cannot allocate memory for bind descriptor" );
                                                                                                    
          
        bind_dp->N = size;  /* Initialize count of array elements. */
        EXEC SQL DESCRIBE BIND VARIABLES FOR S INTO bind_dp;
        if ( sqlca.sqlcode ) return sqlerror_soft(__LINE__);
    }
                                                                                                    
          
    bind_dp->N = bind_dp->F;
    for (i = 0; i < bind_dp->N; i++)
        bind_dp->I[i] = (short *) malloc(sizeof (short));
                                                                                                    
          
    for (i = 0; i < bind_dp->F; i++)
    {
        bind_dp->V[i] = bindValues[i];
        bind_dp->L[i] = strlen(bind_dp->V[i]);
        *bind_dp->I[i] = (*bind_dp->V[i]) ? 0 : -1;
        if ( *bind_dp->I[i] )
        {
            bind_dp->V[i] = (char *)malloc(5);
            bind_dp->L[i] = 4;
        }
        bind_dp->T[i] = 1;
    }
    EXEC SQL OPEN C USING DESCRIPTOR bind_dp;
    if ( sqlca.sqlcode ) return sqlerror_soft(__LINE__);
                                                                                                    
          
    for( i = 0; i < bind_dp->N; i++ ) free( bind_dp->I[i] );
    sqlclu( bind_dp );
}
#endif
