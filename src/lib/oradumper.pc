/* -*-mode: c-*- */
/*******************************************************************
ANSI Dynamic Demo 2:  ANSI Dynamic SQL with reference semantics,
                           batch processing and local descriptor
                           names in host variables
                           
This program demonstates using ANSI Dynamic SQL to process SQL
statements which are not known until runtime.  It uses the Oracle
extensions for batch processing and reference semantics.

The program connects you to ORACLE using your username and password,
then prompts you for a SQL statement.  Enter legal SQL or PL/SQL 
statement using interactive, not embedded, SQL syntax, terminating the 
statement with a seimcolon.  Your statement will be processed.  If it
is a query, the fetched rows are displayed. 

If your statement has input bind variables (other than in a where clause),
the program will ask for an input array size and then allow you to enter 
that number of input values. If your statment has output, the program will
ask you for an output array size and will do array fetchng using that value.
It will also output the rows fetched in one batch together, so using a small
value for the output array size will improve the look of the output.  
For example, connected as scott/tiger, try select empno, ename from emp
with an output array size of 4;

You can enter multi-line statements.  The limit is 1023 characters.
There is a limit on the size of the variables, MAX_VAR_LEN, defined as 255.
This program processes up to 40 bind variables and 40 select-list items.

Precompile with program with dynamic=ansi, i.e:
 
proc dynamic=ansi ansidyn2

*******************************************************************/

#if HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif

#if HAVE_STRING_H
#include <string.h>
#endif

#if HAVE_SQLCPR_H
#include <sqlcpr.h>
#endif

#if HAVE_DBUG_H
#include <dbug.h>
#endif

#include "oradumper.h"
#include "oradumper_int.h"

#ifndef NULL
#define NULL  0
#endif

/* Prototypes */
static void sql_error(void);
static int oracle_connect(void);
static int process_input(void);
static int process_output(void);
static void process_data(const int output_count, int *rows_this_fetch, int *cumulative_rows);
static void rows_processed(const char *select_statement);

EXEC SQL INCLUDE sqlca;

EXEC SQL BEGIN DECLARE SECTION;
#define MAX_OCCURENCES  40
#define MAX_ARRSZ      100
#define MAX_VAR_LEN    255
#define MAX_NAME_LEN    31

char  indesc[]="input_descriptor";                /* descriptor names       */
char outdesc[]="output_descriptor";
char   input[MAX_OCCURENCES][MAX_VAR_LEN +1 ],    /* data areas */
      output[MAX_OCCURENCES][MAX_ARRSZ][MAX_VAR_LEN + 1];

short outindi[MAX_OCCURENCES][MAX_ARRSZ];        /* output indicators      */
short *iptr;

const int max_array_size = MAX_ARRSZ;   /* maximum arrays size used for allocates */
const int out_array_size = MAX_ARRSZ;          /* size of output batch, i.e., number of rows */
EXEC SQL END DECLARE SECTION;

char *dml_commands[] = {"SELECT", "select"};

int cursor_open = 0;

/* A global flag for the error routine. */
int parse_flag = 0;

error_t
sql_connect(userid)
EXEC SQL BEGIN DECLARE SECTION;
const char *userid;
EXEC SQL VAR userid IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_connect");

  EXEC SQL WHENEVER SQLERROR CONTINUE;

  EXEC SQL CONNECT :userid;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_execute_immediate(statement)
EXEC SQL BEGIN DECLARE SECTION;
const char *statement;
EXEC SQL VAR statement IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_execute_immediate");
  DBUG_PRINT("input", ("statement: %s", statement));

  EXEC SQL WHENEVER SQLERROR CONTINUE;

  EXEC SQL EXECUTE IMMEDIATE :statement;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_allocate_descriptors(max_array_size)
EXEC SQL BEGIN DECLARE SECTION;
const unsigned int max_array_size;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_allocate_descriptors");
  DBUG_PRINT("input", ("max_array_size: %u", max_array_size));

  /* Allocate the input and output descriptors. */
  /* The input is only used for query bind variables hence no array processing */
  EXEC SQL
    ALLOCATE DESCRIPTOR LOCAL :indesc;
  EXEC SQL FOR :max_array_size
    ALLOCATE DESCRIPTOR LOCAL :outdesc;
      
  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_parse(select_statement)
EXEC SQL BEGIN DECLARE SECTION;
const char *select_statement;
EXEC SQL VAR select_statement IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_parse");
  DBUG_PRINT("input", ("select_statement: %s", select_statement));

  /* Prepare the statement and declare a cursor. */
  parse_flag = 1;     /* Set a flag for sql_error(). */
  EXEC SQL PREPARE S FROM :select_statement;
  parse_flag = 0;     /* Unset the flag. */
  EXEC SQL DECLARE C CURSOR FOR S;
  EXEC SQL DESCRIBE INPUT S USING DESCRIPTOR LOCAL :indesc;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_bind_variable_count(count)
EXEC SQL BEGIN DECLARE SECTION;
unsigned int *count;
EXEC SQL END DECLARE SECTION;
{

  DBUG_ENTER("sql_bind_variable_count");

  EXEC SQL GET DESCRIPTOR LOCAL :indesc :count = COUNT; 

  DBUG_PRINT("output", ("count: %u; return: %d", *count, sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_bind_variable_name(nr, size, name);
EXEC SQL BEGIN DECLARE SECTION;
unsigned int nr;
const size_t size;
char *name;
EXEC SQL END DECLARE SECTION;
{
  EXEC SQL BEGIN DECLARE SECTION;
  char bind_variable_name[MAX_NAME_LEN];
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("sql_bind_variable_name");
  DBUG_PRINT("input", ("nr: %u; size: %d", nr, (int) size));

  EXEC SQL GET DESCRIPTOR LOCAL :indesc
    VALUE :nr :bind_variable_name = NAME;

  (void) strncpy(name, bind_variable_name, size - 1);
  name[size - 1] = '\0';

  DBUG_PRINT("output", ("name: %s; return: %d", name, sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_bind_variable(nr, value)
EXEC SQL BEGIN DECLARE SECTION;
unsigned int nr;
const char *value;
EXEC SQL END DECLARE SECTION;
{
  EXEC SQL BEGIN DECLARE SECTION;
  const int type = ANSI_CHARACTER_VARYING;
  const short ind = (value == NULL ? -1 : 0);
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("sql_bind_variable_name");
  DBUG_PRINT("input", ("nr: %u; value: %s", nr, value));

  EXEC SQL SET DESCRIPTOR LOCAL :indesc
    VALUE :nr TYPE = :type, DATA = :value, INDICATOR = :ind;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_open_cursor(void)
{
  DBUG_ENTER("sql_open_cursor");

  /* Open the cursor and execute the statement. */
  EXEC SQL
    OPEN C USING DESCRIPTOR LOCAL :indesc;
  cursor_open = 1;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_column_count(count)
EXEC SQL BEGIN DECLARE SECTION;
unsigned int *count;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_column_count");

  EXEC SQL DESCRIBE OUTPUT S USING DESCRIPTOR LOCAL :outdesc;
   
  EXEC SQL GET DESCRIPTOR LOCAL :outdesc :count = COUNT;

  DBUG_PRINT("output", ("count: %u; return: %d", *count, sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_describe_column(nr, size, name, type, length)
EXEC SQL BEGIN DECLARE SECTION;
const unsigned int nr;
const size_t size;
char *name;
int *type;
unsigned int *length;
EXEC SQL END DECLARE SECTION;
{
  EXEC SQL BEGIN DECLARE SECTION;
  char column_name[MAX_NAME_LEN];
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("sql_describe_column");
  DBUG_PRINT("input", ("nr: %u; size: %d", nr, (int) size));

  EXEC SQL GET DESCRIPTOR LOCAL :outdesc VALUE :nr
    :type = TYPE, :column_name = NAME, :length = LENGTH;

  (void) strncpy(name, column_name, size - 1);
  name[size - 1] = '\0';

  DBUG_PRINT("output", ("name: %s; type: %d; length: %u; return: %d", name, *type, *length, sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_define_column(nr, type, length, array_size, data, ind);
EXEC SQL BEGIN DECLARE SECTION;
const unsigned int nr;
const int type;
const unsigned int length;
const unsigned int array_size;
const char *data[];
const unsigned short ind[];
EXEC SQL END DECLARE SECTION;
{
  EXEC SQL BEGIN DECLARE SECTION;
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("sql_define_column");
  DBUG_PRINT("input",
	     ("nr: %u; type: %d; length: %u; array_size: %u",
	      nr,
	      type,
	      length,
	      array_size));

  EXEC SQL SET DESCRIPTOR LOCAL :outdesc VALUE :nr
    TYPE = :type, LENGTH = :length;
   
  EXEC SQL FOR :array_size
    SET DESCRIPTOR LOCAL :outdesc VALUE :nr
    REF DATA = :data, REF INDICATOR = :ind;

  DBUG_LEAVE();

  return sqlca.sqlcode;
}

/**/

static
int
process_output(void)
{
  int i, j;
  EXEC SQL BEGIN DECLARE SECTION;
  int output_count, occurs;
  int type, output_len = MAX_VAR_LEN;
  char name[MAX_OCCURENCES][MAX_NAME_LEN];
  int rows_this_fetch = 0, cumulative_rows = 0;
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("process_output");


  DBUG_PRINT("info", ("number of columns: %d", output_count));
  
  for (i = 0; i < output_count; i++)
    {
      occurs = i + 1;

      DBUG_PRINT("info", ("column %d has name %s and type %d", occurs, name[i], type));

      type = ORA_STRING; /* force all data to be null terminated character */
    }   
      
  /* print the column headings */
  for (j = 0; j < 2; j++)
    {
      for (i = 0; i < output_count; i++)
	{
	  printf("%-*.*s ", 30, 30, (j == 0 ? name[i] : "------------------------------"));
	}
      printf("\n");
    }
   
  /* FETCH each row selected and print the column values. */
  for (;;)
    {
      EXEC SQL WHENEVER NOT FOUND GOTO end_of_fetch_loop;
      EXEC SQL FOR :out_array_size 
	FETCH C INTO DESCRIPTOR LOCAL :outdesc;
      
      process_data(output_count, &rows_this_fetch, &cumulative_rows);
    }

 end_of_fetch_loop:
  process_data(output_count, &rows_this_fetch, &cumulative_rows);

  DBUG_LEAVE();

  return(0);
}

static
void
process_data(const int output_count, int *rows_this_fetch, int *cumulative_rows)
{
  int i, j;

  *rows_this_fetch = sqlca.sqlerrd[2] - *cumulative_rows;
  *cumulative_rows = sqlca.sqlerrd[2];

  DBUG_PRINT("info", ("rows fetched: %d; rows fetched cumulative: %d", *rows_this_fetch, *cumulative_rows));

  if (*rows_this_fetch != 0)
    {
      for (j = 0; j < out_array_size && j < *rows_this_fetch; j++)
	{           /* output by columns using simplified formatting */
	  for (i = 0; i < output_count; i++)
	    {                              
	      printf("%-*.*s ", 30, 30, (outindi[i][j] == -1 ? "NULL" : output[i][j]));  /* simplified */
	      /* output formatting may cause truncation */
	      /* but columns will line up */
	    }
	  printf ("\n");
	}
    }
}

static
void
rows_processed(const char *select_statement)
{  
  int i;

  DBUG_ENTER("rows_processed");

  for (i = 0; i < 8; i++)
    {
      if (strncmp(select_statement, dml_commands[i], 6) == 0)
	{
	  fprintf(stderr, "\n\n%d row%c processed.\n", sqlca.sqlerrd[2],
		 sqlca.sqlerrd[2] == 1 ? ' ' : 's');
	  break;
	}
    }

  DBUG_LEAVE();
}

static
void
sql_error()
{
  DBUG_ENTER("sql_error");

  /* ORACLE error handler */
  fprintf(stderr, "\n\n%.70s\n",sqlca.sqlerrm.sqlerrmc);
  if (parse_flag)
    fprintf
      (stderr, "Parse error at character offset %d in SQL statement.\n",
       sqlca.sqlerrd[4]);

  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL ROLLBACK WORK;

  DBUG_LEAVE();

  exit (EXIT_FAILURE);
}

/**/

error_t
sql_close_cursor(void)
{
  DBUG_ENTER("sql_close_cursor");

  EXEC SQL CLOSE C;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}


error_t
sql_deallocate_descriptors(void)
{
  DBUG_ENTER("sql_deallocate_descriptors");

  /* Deallocate the descriptors */
  EXEC SQL DEALLOCATE DESCRIPTOR LOCAL :indesc;
  EXEC SQL DEALLOCATE DESCRIPTOR LOCAL :outdesc;
      
  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}
