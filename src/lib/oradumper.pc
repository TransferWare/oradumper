/* -*-mode: c-*- */
/*******************************************************************
ANSI Dynamic Demo 2:  ANSI Dynamic SQL with reference semantics,
                           batch processing and local descriptor
                           names in host variables
                           
This program demonstates using ANSI Dynamic SQL to process SQL
statements which are not known until runtime.  It uses the Oracle
extensions for batch processing and reference semantics.

The program connects you to ORACLE using your username and password,
then prompts you for a SQL statement.  Enter legal SQL or PL/SQL 
statement using interactive, not embedded, SQL syntax, terminating the 
statement with a seimcolon.  Your statement will be processed.  If it
is a query, the fetched rows are displayed. 

If your statement has input bind variables (other than in a where clause),
the program will ask for an input array size and then allow you to enter 
that number of input values. If your statment has output, the program will
ask you for an output array size and will do array fetchng using that value.
It will also output the rows fetched in one batch together, so using a small
value for the output array size will improve the look of the output.  
For example, connected as scott/tiger, try select empno, ename from emp
with an output array size of 4;

You can enter multi-line statements.  The limit is 1023 characters.
There is a limit on the size of the variables, MAX_VAR_LEN, defined as 255.
This program processes up to 40 bind variables and 40 select-list items.

Precompile with program with dynamic=ansi, i.e:
 
proc dynamic=ansi ansidyn2

*******************************************************************/

#if HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif

#if HAVE_STRING_H
#include <string.h>
#endif

#if HAVE_SQLCPR_H
#include <sqlcpr.h>
#endif

#if HAVE_DBUG_H
#include <dbug.h>
#endif

#include "oradumper.h"
#include "oradumper_int.h"

#ifndef NULL
#define NULL  0
#endif

/* Prototypes */
static void sql_error(void);
static int oracle_connect(void);
static int process_input(void);
static int process_output(void);
static void process_data(const int output_count, int *rows_this_fetch, int *cumulative_rows);
static void rows_processed(const char *select_statement);

EXEC SQL INCLUDE sqlca;

EXEC SQL BEGIN DECLARE SECTION;
#define MAX_OCCURENCES  40
#define MAX_ARRSZ      100
#define MAX_VAR_LEN    255
#define MAX_NAME_LEN    31

char  indesc[]="input_descriptor";                /* descriptor names       */
char outdesc[]="output_descriptor";
char   input[MAX_OCCURENCES][MAX_VAR_LEN +1 ],    /* data areas */
      output[MAX_OCCURENCES][MAX_ARRSZ][MAX_VAR_LEN + 1];

short outindi[MAX_OCCURENCES][MAX_ARRSZ];        /* output indicators      */
short *iptr;

const int max_array_size = MAX_ARRSZ;   /* maximum arrays size used for allocates */
const int out_array_size = MAX_ARRSZ;          /* size of output batch, i.e., number of rows */
EXEC SQL END DECLARE SECTION;

char *dml_commands[] = {"SELECT", "select"};

int cursor_open = 0;

/* A global flag for the error routine. */
int parse_flag = 0;

static int process(const char *select_statement);

int
oradumper(const unsigned int length, const char **options)
{
  process_options(length, options);

  DBUG_INIT(get_option(OPTION_DBUG_OPTIONS), "oradumper");

  process(get_option(OPTION_SQLSTMT));

  DBUG_DONE();
}

static
int
process(select_statement)
EXEC SQL BEGIN DECLARE SECTION;
const char *select_statement;                      /* statement variable     */
EXEC SQL VAR select_statement IS STRING;
EXEC SQL END DECLARE SECTION;
{
  int status = 1;
  EXEC SQL BEGIN DECLARE SECTION;
#define NLS_MAX_SIZE 100
  char nls_date_format[NLS_MAX_SIZE+1];
  EXEC SQL VAR nls_date_format IS STRING(NLS_MAX_SIZE);
  char nls_timestamp_format[NLS_MAX_SIZE+1];
  EXEC SQL VAR nls_timestamp_format IS STRING(NLS_MAX_SIZE);
  char nls_numeric_characters[NLS_MAX_SIZE+1];
  EXEC SQL VAR nls_numeric_characters IS STRING(NLS_MAX_SIZE);
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("process");

  /* Connect to the database. */
  if (oracle_connect() != 0)
    {
      goto end_of_process;
    }

  EXEC SQL WHENEVER SQLERROR DO sql_error();

  snprintf(nls_date_format,
	   sizeof(nls_date_format),
	   "ALTER SESSION SET NLS_DATE_FORMAT = '%s'",
	   get_option(OPTION_NLS_DATE_FORMAT));
  snprintf(nls_timestamp_format,
	   sizeof(nls_timestamp_format),
	   "ALTER SESSION SET NLS_TIMESTAMP_FORMAT = '%s'",
	   get_option(OPTION_NLS_TIMESTAMP_FORMAT));
  snprintf(nls_numeric_characters,
	   sizeof(nls_numeric_characters),
	   "ALTER SESSION SET NLS_NUMERIC_CHARACTERS = '%s'",
	   get_option(OPTION_NLS_NUMERIC_CHARACTERS));

  EXEC SQL EXECUTE IMMEDIATE :nls_date_format;
  EXEC SQL EXECUTE IMMEDIATE :nls_timestamp_format;
  EXEC SQL EXECUTE IMMEDIATE :nls_numeric_characters;

  /* Allocate the input and output descriptors. */
  /* The input is only used for query bind variables hence no array processing */
  EXEC SQL
    ALLOCATE DESCRIPTOR LOCAL :indesc;
  EXEC SQL FOR :max_array_size
    ALLOCATE DESCRIPTOR LOCAL :outdesc;

  /* Prepare the statement and declare a cursor. */
  parse_flag = 1;     /* Set a flag for sql_error(). */
  EXEC SQL PREPARE S FROM :select_statement;
  parse_flag = 0;     /* Unset the flag. */

  EXEC SQL DECLARE C CURSOR FOR S;
      
  /* Call the function that processes the input. */
  if (process_input() != 0)
    {
      goto end_of_process;
    }

  /* Open the cursor and execute the statement. */
  EXEC SQL
    OPEN C USING DESCRIPTOR LOCAL :indesc;
  cursor_open = 1;
 
  /* Call the function that processes the output. */
  if (process_output() != 0)
    {
      goto end_of_process;
    }

  /* Tell user how many rows were processed. */
  rows_processed(select_statement);

  /* Close the cursor. */
  if (cursor_open != 0)
    {
      EXEC SQL CLOSE C;
    }

  /* Deallocate the descriptors */
  EXEC SQL DEALLOCATE DESCRIPTOR LOCAL :indesc;
  EXEC SQL DEALLOCATE DESCRIPTOR LOCAL :outdesc;
  
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL COMMIT WORK RELEASE;

  EXEC SQL WHENEVER SQLERROR DO sql_error();

  status = 0;

 end_of_process:
  DBUG_LEAVE();

  return status;
}

static
int
process_input(void)
{
  int i;
  EXEC SQL BEGIN DECLARE SECTION;
  int input_count, occurs;
  const int type = ANSI_CHARACTER_VARYING;
  const int length = MAX_VAR_LEN;
  char name[MAX_NAME_LEN];
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("process_input");

  EXEC SQL DESCRIBE INPUT S USING DESCRIPTOR LOCAL :indesc;
  EXEC SQL GET DESCRIPTOR LOCAL :indesc :input_count = COUNT; 

  DBUG_PRINT("info", ("number of bind variables: %d", input_count));

  for (i = 0; i < input_count; i++)
    {
      occurs = i + 1;                       /* occurence is 1 based */

      EXEC SQL GET DESCRIPTOR LOCAL :indesc
	VALUE :occurs :name = NAME;

      DBUG_PRINT("info", ("bind variable %d has name %s", occurs, name));

      EXEC SQL SET DESCRIPTOR LOCAL :indesc
	VALUE :occurs TYPE = :type, LENGTH = :length, REF DATA = :input[i];
    }

  DBUG_LEAVE();

  return sqlca.sqlcode;
}

static
int
process_output(void)
{
  int i, j;
  EXEC SQL BEGIN DECLARE SECTION;
  int output_count, occurs;
  int type, output_len = MAX_VAR_LEN;
  char name[MAX_OCCURENCES][MAX_NAME_LEN];
  int rows_this_fetch = 0, cumulative_rows = 0;
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("process_output");

  EXEC SQL DESCRIBE OUTPUT S USING DESCRIPTOR LOCAL :outdesc;
   
  EXEC SQL GET DESCRIPTOR LOCAL :outdesc :output_count = COUNT;

  DBUG_PRINT("info", ("number of columns: %d", output_count));
  
  for (i = 0; i < output_count; i++)
    {
      occurs = i + 1;
      EXEC SQL GET DESCRIPTOR LOCAL :outdesc VALUE :occurs
	:type = TYPE, :name[i] = NAME;

      DBUG_PRINT("info", ("column %d has name %s and type %d", occurs, name[i], type));

      type = ORA_STRING; /* force all data to be null terminated character */
      EXEC SQL SET DESCRIPTOR LOCAL :outdesc VALUE :occurs 
	TYPE = :type, LENGTH = :output_len;
   
      iptr = (short *)&outindi[i]; /* no mult-dimension non-char host vars */
      EXEC SQL FOR :out_array_size
	SET DESCRIPTOR LOCAL :outdesc VALUE :occurs 
	REF DATA = :output[i], REF INDICATOR = :iptr;
    }   
      
  /* print the column headings */
  for (j = 0; j < 2; j++)
    {
      for (i = 0; i < output_count; i++)
	{
	  printf("%-*.*s ", 30, 30, (j == 0 ? name[i] : "------------------------------"));
	}
      printf("\n");
    }
   
  /* FETCH each row selected and print the column values. */
  for (;;)
    {
      EXEC SQL WHENEVER NOT FOUND GOTO end_of_fetch_loop;
      EXEC SQL FOR :out_array_size 
	FETCH C INTO DESCRIPTOR LOCAL :outdesc;
      
      process_data(output_count, &rows_this_fetch, &cumulative_rows);
    }

 end_of_fetch_loop:
  process_data(output_count, &rows_this_fetch, &cumulative_rows);

  DBUG_LEAVE();

  return(0);
}

static
void
process_data(const int output_count, int *rows_this_fetch, int *cumulative_rows)
{
  int i, j;

  *rows_this_fetch = sqlca.sqlerrd[2] - *cumulative_rows;
  *cumulative_rows = sqlca.sqlerrd[2];

  DBUG_PRINT("info", ("rows fetched: %d; rows fetched cumulative: %d", *rows_this_fetch, *cumulative_rows));

  if (*rows_this_fetch != 0)
    {
      for (j = 0; j < out_array_size && j < *rows_this_fetch; j++)
	{           /* output by columns using simplified formatting */
	  for (i = 0; i < output_count; i++)
	    {                              
	      printf("%-*.*s ", 30, 30, (outindi[i][j] == -1 ? "NULL" : output[i][j]));  /* simplified */
	      /* output formatting may cause truncation */
	      /* but columns will line up */
	    }
	  printf ("\n");
	}
    }
}

static
void
rows_processed(const char *select_statement)
{  
  int i;

  DBUG_ENTER("rows_processed");

  for (i = 0; i < 8; i++)
    {
      if (strncmp(select_statement, dml_commands[i], 6) == 0)
	{
	  fprintf(stderr, "\n\n%d row%c processed.\n", sqlca.sqlerrd[2],
		 sqlca.sqlerrd[2] == 1 ? ' ' : 's');
	  break;
	}
    }

  DBUG_LEAVE();
}

static
void
sql_error()
{
  DBUG_ENTER("sql_error");

  /* ORACLE error handler */
  fprintf(stderr, "\n\n%.70s\n",sqlca.sqlerrm.sqlerrmc);
  if (parse_flag)
    fprintf
      (stderr, "Parse error at character offset %d in SQL statement.\n",
       sqlca.sqlerrd[4]);

  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL ROLLBACK WORK;

  DBUG_LEAVE();

  exit (EXIT_FAILURE);
}

static
int
oracle_connect()
{
  int status = 1;
  EXEC SQL BEGIN DECLARE SECTION;
  const char *userid = get_option(OPTION_USERID);
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("oracle_connect");

  EXEC SQL WHENEVER SQLERROR GOTO connect_error;

  EXEC SQL CONNECT :userid;

  fprintf(stderr, "\nConnected to ORACLE as %s.\n", userid);

  status = 0;
  goto end_of_oracle_connect;

 connect_error:
  fprintf(stderr, "Can not connect to ORACLE as %s.\n", userid);

 end_of_oracle_connect:

  DBUG_LEAVE();

  return status;
}
