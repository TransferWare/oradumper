/* -*-mode: c-*- */
/*******************************************************************
ANSI Dynamic Demo 2:  ANSI Dynamic SQL with reference semantics,
                           batch processing and global descriptor
                           names in host variables
                           
This program demonstates using ANSI Dynamic SQL to process SQL
statements which are not known until runtime.  It uses the Oracle
extensions for batch processing and reference semantics.

The program connects you to ORACLE using your username and password,
then prompts you for a SQL statement.  Enter legal SQL or PL/SQL 
statement using interactive, not embedded, SQL syntax, terminating the 
statement with a seimcolon.  Your statement will be processed.  If it
is a query, the fetched rows are displayed. 

If your statement has input bind variables (other than in a where clause),
the program will ask for an input array size and then allow you to enter 
that number of input values. If your statment has output, the program will
ask you for an output array size and will do array fetchng using that value.
It will also output the rows fetched in one batch together, so using a small
value for the output array size will improve the look of the output.  
For example, connected as scott/tiger, try select empno, ename from emp
with an output array size of 4;

You can enter multi-line statements.  The limit is 1023 characters.
There is a limit on the size of the variables, MAX_VAR_LEN, defined as 255.
This program processes up to 40 bind variables and 40 select-list items.

Precompile with program with dynamic=ansi, i.e:
 
proc dynamic=ansi ansidyn2

*******************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sqlcpr.h>

#include "oradumper.h"
#include "oradumper_int.h"

#ifndef NULL
#define NULL  0
#endif

/* Prototypes */
static void sql_error(void);
static int oracle_connect(void);
static int process_input(void);
static int process_output(void);
static void rows_processed(const char *select_statement);

EXEC SQL INCLUDE sqlca;

EXEC SQL BEGIN DECLARE SECTION;
#define MAX_OCCURENCES  40
#define MAX_ARRSZ      100
#define MAX_VAR_LEN    255
#define MAX_NAME_LEN    31

char  indesc[]="input_descriptor";                /* descriptor names       */
char outdesc[]="output_descriptor";
char   input[MAX_OCCURENCES][MAX_ARRSZ][MAX_VAR_LEN +1 ],    /* data areas */
      output[MAX_OCCURENCES][MAX_ARRSZ][MAX_VAR_LEN + 1];

short outindi[MAX_OCCURENCES][MAX_ARRSZ];        /* output indicators      */
short *iptr;

const int in_array_size = 1;           /* size of input batch, i.e., number of rows (1 for select) */

const int max_array_size = MAX_ARRSZ;   /* maximum arrays size used for allocates */
const int out_array_size = MAX_ARRSZ;          /* size of output batch, i.e., number of rows */
EXEC SQL END DECLARE SECTION;

char *dml_commands[] = {"SELECT", "select"};

int cursor_open = 0;

/* A global flag for the error routine. */
int parse_flag = 0;

static int process(const char *select_statement);

int
oradumper(const unsigned int length, const char **options)
{
  process_options(length, options);
  process(get_option(OPTION_SQLSTMT));
}

static
int
process(select_statement)
EXEC SQL BEGIN DECLARE SECTION;
const char *select_statement;                      /* statement variable     */
EXEC SQL VAR select_statement IS STRING(1024);
EXEC SQL END DECLARE SECTION;
{
  /* Connect to the database. */
  if (oracle_connect() != 0)
    {
      return 1;
    }

  EXEC SQL WHENEVER SQLERROR DO sql_error();

  /* Allocate the input and output descriptors. */
  EXEC SQL FOR :max_array_size
    ALLOCATE DESCRIPTOR GLOBAL :indesc;
  EXEC SQL FOR :max_array_size
    ALLOCATE DESCRIPTOR GLOBAL :outdesc;

  /* Prepare the statement and declare a cursor. */
  parse_flag = 1;     /* Set a flag for sql_error(). */
  EXEC SQL PREPARE S FROM :select_statement;
  parse_flag = 0;     /* Unset the flag. */

  EXEC SQL DECLARE C CURSOR FOR S;
      
  /* Call the function that processes the input. */
  if (process_input() != 0)
    {
      return 1;
    }

  /* Open the cursor and execute the statement. */
  EXEC SQL FOR :in_array_size
    OPEN C USING DESCRIPTOR GLOBAL :indesc;
  cursor_open = 1;
 
  /* Call the function that processes the output. */
  if (process_output() != 0)
    {
      return 1;
    }

  /* Tell user how many rows were processed. */
  rows_processed(select_statement);

  /* Close the cursor. */
  if (cursor_open != 0)
    {
      EXEC SQL CLOSE C;
    }

  /* Deallocate the descriptors */
  EXEC SQL DEALLOCATE DESCRIPTOR GLOBAL :indesc;
  EXEC SQL DEALLOCATE DESCRIPTOR GLOBAL :outdesc;
  
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL COMMIT WORK RELEASE;
  puts("\nHave a good day!\n");

  EXEC SQL WHENEVER SQLERROR DO sql_error();
}

static
int
process_input(void)
{
  int i, j;
  EXEC SQL BEGIN DECLARE SECTION;
  int  input_count, input_len= MAX_VAR_LEN;
  int  occurs, string_type = 5;
  int  string_len;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL DESCRIBE INPUT S USING DESCRIPTOR GLOBAL :indesc;
  EXEC SQL GET DESCRIPTOR GLOBAL :indesc :input_count = COUNT; 

  for (i = 0; i < input_count; i++)
    {
      occurs = i + 1;                       /* occurence is 1 based */

      for (j=0; j < in_array_size; j++)
        {
          string_len = strlen(input[i][j]);
        }

      EXEC SQL SET DESCRIPTOR GLOBAL :indesc
	VALUE :occurs TYPE = :string_type, LENGTH = :input_len;
      EXEC SQL FOR :in_array_size
	SET DESCRIPTOR GLOBAL :indesc
	VALUE :occurs REF DATA = :input[i];
    }

  return sqlca.sqlcode;
}

static
int
process_output(void)
{
  int i, j;
  EXEC SQL BEGIN DECLARE SECTION;
  int output_count, occurs;
  int type, output_len= MAX_VAR_LEN;
  char name[MAX_OCCURENCES][MAX_NAME_LEN];
  int rows_this_fetch=0, cumulative_rows=0;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL DESCRIBE OUTPUT S USING DESCRIPTOR GLOBAL :outdesc;
   
  EXEC SQL GET DESCRIPTOR GLOBAL :outdesc :output_count = COUNT;
  
  for (i = 0; i < output_count; i++)
    {
      occurs = i + 1;
      EXEC SQL GET DESCRIPTOR GLOBAL :outdesc VALUE :occurs
	:type = TYPE, :name[i] = NAME;
      occurs = i + 1;                         /* occurence is one based */
      type = 5;  /* force all data to be null terminated character */
      EXEC SQL SET DESCRIPTOR GLOBAL :outdesc VALUE :occurs 
	TYPE = :type, LENGTH = :output_len;
   
      iptr = (short *)&outindi[i]; /* no mult-dimension non-char host vars */
      EXEC SQL FOR :out_array_size
	SET DESCRIPTOR GLOBAL :outdesc VALUE :occurs 
	REF DATA = :output[i], REF INDICATOR = :iptr;
    }   
   
  EXEC SQL WHENEVER NOT FOUND GOTO end_select_loop;
   
  /* print the column headings */
  for (i=0; i < output_count; i++)
    printf("%-*.*s ", 9,9, name[i]);
  printf("\n");
   
  /* FETCH each row selected and print the column values. */
  for (;;)
    {
      EXEC SQL FOR :out_array_size 
	FETCH C INTO DESCRIPTOR GLOBAL :outdesc;
      rows_this_fetch = sqlca.sqlerrd[2] - cumulative_rows;
      cumulative_rows = sqlca.sqlerrd[2];
      if (rows_this_fetch)
	for (j=0; j < out_array_size && j < rows_this_fetch; j++)
	  {           /* output by columns using simplified formatting */
	    for (i=0; i < output_count; i++)
	      {                              
                if (outindi[i][j] == -1)       
		  printf("%-*.*s ", 9, 9, "NULL");
		else
                  printf("%-*.*s ", 9, 9, output[i][j]);  /* simplified */
		/* output formatting may cause truncation */
		/* but columns will line up */
	      } 
	  }
      printf ("\n");
    }

end_select_loop:
  /* print any unprinted rows */
  rows_this_fetch = sqlca.sqlerrd[2] - cumulative_rows;
  cumulative_rows = sqlca.sqlerrd[2];
  if (rows_this_fetch)
    for (j=0; j < out_array_size && j < rows_this_fetch; j++)
      {           /* output by columns using simplified formatting */
	for (i=0; i < output_count; i++)
	  {                              
	    if (outindi[i][j] == -1)       
	      printf("%-*.*s ",9, 9, "NULL");
	    else
	      printf("%-*.*s ", 9, 9, output[i][j]); 
	  } 
      }
   return(0);
}

static
void
rows_processed(const char *select_statement)
{  
  int i;
  for (i = 0; i < 8; i++)
    {
      if (strncmp(select_statement, dml_commands[i], 6) == 0)
	{
	  printf("\n\n%d row%c processed.\n", sqlca.sqlerrd[2],
		 sqlca.sqlerrd[2] == 1 ? ' ' : 's');
	  break;
	}
    }
  return;
}

static
void
sql_error()
{
  /* ORACLE error handler */
  printf ("\n\n%.70s\n",sqlca.sqlerrm.sqlerrmc);
  if (parse_flag)
    printf
      ("Parse error at character offset %d in SQL statement.\n",
       sqlca.sqlerrd[4]);

  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL ROLLBACK WORK;

  exit (EXIT_FAILURE);
}

static
int
oracle_connect()
{
  EXEC SQL BEGIN DECLARE SECTION;
  const char *userid = get_option(OPTION_USERID);
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR GOTO connect_error;

  EXEC SQL CONNECT :userid;

  printf("\nConnected to ORACLE as %s.\n", userid);

  return 0;

 connect_error:
  fprintf(stderr, "Can not connect to ORACLE as %s.\n", userid);
  return -1;
}
