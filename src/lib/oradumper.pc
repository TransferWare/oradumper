/* -*-mode: c-*- */

#if HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif

#if HAVE_STRING_H
#include <string.h>
#endif

#if HAVE_SQLCPR_H
#include <sqlcpr.h>
#endif

#if HAVE_DBUG_H
#include <dbug.h>
#endif

/* include dmalloc as last one */
#ifdef WITH_DMALLOC
#include <dmalloc.h>
#endif

#include "oradumper.h"

#define varchar_defined 1

EXEC SQL INCLUDE "oradumper_int.h";

/* declare a structure */
#ifdef SQLCA_NONE 
#undef SQLCA_NONE 
#endif

#ifdef SQLCA_STORAGE_CLASS
#undef SQLCA_STORAGE_CLASS
#endif

/* a static sqlca only */
#define SQLCA_STORAGE_CLASS static

/* force initialisation of the static sqlca struct */
#ifndef SQLCA_INIT
#define SQLCA_INIT
#endif

EXEC SQL INCLUDE sqlca;

EXEC SQL BEGIN DECLARE SECTION;
#define MAX_NAME_LEN 255
EXEC SQL END DECLARE SECTION;

#define NO_DATA_FOUND 100

error_t
sql_connect(userid)
EXEC SQL BEGIN DECLARE SECTION;
const char *userid;
EXEC SQL VAR userid IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_connect");

  EXEC SQL WHENEVER SQLERROR CONTINUE;

  EXEC SQL CONNECT :userid;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_execute_immediate(statement)
EXEC SQL BEGIN DECLARE SECTION;
const char *statement;
EXEC SQL VAR statement IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_execute_immediate");
  DBUG_PRINT("input", ("statement: %s", statement));

  EXEC SQL WHENEVER SQLERROR CONTINUE;

  EXEC SQL EXECUTE IMMEDIATE :statement;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_allocate_descriptor(descriptor_name, max_array_size)
EXEC SQL BEGIN DECLARE SECTION;
const char *descriptor_name;
EXEC SQL VAR descriptor_name IS STRING;
const unsigned int max_array_size;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_allocate_descriptor");
  DBUG_PRINT("input", ("descriptor_name: %s; max_array_size: %u", descriptor_name, max_array_size));

  EXEC SQL FOR :max_array_size
    ALLOCATE DESCRIPTOR LOCAL :descriptor_name;
      
  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_parse(select_statement)
EXEC SQL BEGIN DECLARE SECTION;
const char *select_statement;
EXEC SQL VAR select_statement IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_parse");
  DBUG_PRINT("input", ("select_statement: %s", select_statement));

  /* Prepare the statement and declare a cursor. */
  EXEC SQL PREPARE S FROM :select_statement;
  EXEC SQL DECLARE C CURSOR FOR S;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_describe_input(descriptor_name)
EXEC SQL BEGIN DECLARE SECTION;
const char *descriptor_name;
EXEC SQL VAR descriptor_name IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_describe_input");
  DBUG_PRINT("input", ("descriptor_name: %s", descriptor_name));

  EXEC SQL DESCRIBE INPUT S USING DESCRIPTOR LOCAL :descriptor_name;
   
  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_value_count(descriptor_name, count)
EXEC SQL BEGIN DECLARE SECTION;
const char *descriptor_name;
EXEC SQL VAR descriptor_name IS STRING;
unsigned int *count;
EXEC SQL END DECLARE SECTION;
{

  DBUG_ENTER("sql_value_count");
  DBUG_PRINT("input", ("descriptor_name: %s", descriptor_name));

  EXEC SQL GET DESCRIPTOR LOCAL :descriptor_name :count = COUNT; 

  DBUG_PRINT("output", ("count: %u; return: %d", *count, sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_value_get(descriptor_name, nr, value_description)
EXEC SQL BEGIN DECLARE SECTION;
const char *descriptor_name;
EXEC SQL VAR descriptor_name IS STRING;
unsigned int nr;
EXEC SQL END DECLARE SECTION;
value_description_t *value_description;
{
  EXEC SQL BEGIN DECLARE SECTION;
  char *name = value_description->name;
  EXEC SQL VAR name IS STRING(30);
  int *type = &value_description->type;
  unsigned int *octet_length = &value_description->octet_length; /* length in bytes */
  unsigned int *length = &value_description->length; /* length in characters */
  int *precision = &value_description->precision;
  int *scale = &value_description->scale;
  char *character_set_name = value_description->character_set_name;
  EXEC SQL VAR character_set_name IS STRING(20);
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("sql_value_get");
  DBUG_PRINT("input", ("descriptor_name: %s; nr: %u", descriptor_name, nr));

  EXEC SQL GET DESCRIPTOR LOCAL :descriptor_name VALUE :nr 
    :name = NAME,
    :type = TYPE,
    :octet_length = OCTET_LENGTH,
    :length = LENGTH,
    :precision = PRECISION,
    :scale = SCALE,
    :character_set_name = CHARACTER_SET_NAME;

  DBUG_PRINT("output", ("name: %s; type: %d; octet_length: %u; length: %u; precision: %d; scale: %d; character set name: %s; return: %d", name, (int) *type, *octet_length, *length, *precision, *scale, character_set_name, sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_value_set(descriptor_name, nr, array_size, value_description, data, ind)
EXEC SQL BEGIN DECLARE SECTION;
const char *descriptor_name;
EXEC SQL VAR descriptor_name IS STRING;
const unsigned int nr;
const unsigned int array_size;
const char *data;
const short *ind;
EXEC SQL END DECLARE SECTION;
value_description_t *value_description;
{
  EXEC SQL BEGIN DECLARE SECTION;
  int type = value_description->type;
  unsigned int length = value_description->length; /* length in characters */
  char *character_set_name = value_description->character_set_name;
  EXEC SQL VAR character_set_name IS STRING(20);
  EXEC SQL END DECLARE SECTION;

  DBUG_ENTER("sql_value_set");
  DBUG_PRINT("input",
	     ("descriptor_name: %s; nr: %u; array_size: %u; type: %d; length: %u; data: %p; ind: %p",
	      descriptor_name,
	      nr,
	      array_size,
	      type,
	      length,
	      data,
	      ind));

  EXEC SQL SET DESCRIPTOR LOCAL :descriptor_name VALUE :nr
    TYPE = :type,
    LENGTH = :length,
    CHARACTER_SET_NAME = :character_set_name;
   
  EXEC SQL FOR :array_size
    SET DESCRIPTOR LOCAL :descriptor_name VALUE :nr
    REF DATA = :data, REF INDICATOR = :ind;

  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_open_cursor(descriptor_name)
EXEC SQL BEGIN DECLARE SECTION;
const char *descriptor_name;
EXEC SQL VAR descriptor_name IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_open_cursor");

  /* Open the cursor and execute the statement. */
  EXEC SQL
    OPEN C USING DESCRIPTOR LOCAL :descriptor_name;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_describe_output(descriptor_name)
EXEC SQL BEGIN DECLARE SECTION;
const char *descriptor_name;
EXEC SQL VAR descriptor_name IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_describe_output");
  DBUG_PRINT("input", ("descriptor_name: %s", descriptor_name));

  EXEC SQL DESCRIBE OUTPUT S USING DESCRIPTOR LOCAL :descriptor_name;
   
  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_fetch_rows(descriptor_name, array_size, count)
EXEC SQL BEGIN DECLARE SECTION;
const char *descriptor_name;
EXEC SQL VAR descriptor_name IS STRING;
const unsigned int array_size;
EXEC SQL END DECLARE SECTION;
unsigned int *count;
{
  DBUG_ENTER("sql_fetch_rows");
  DBUG_PRINT("input", ("array_size: %u", array_size));

  switch (sqlca.sqlcode)
    {
    case NO_DATA_FOUND:
      *count = 0;
      sqlca.sqlcode = OK;
      break;

    case OK:
      *count = (unsigned int) sqlca.sqlerrd[2]; /* save old cumulative count */

      EXEC SQL WHENEVER NOT FOUND CONTINUE;
      EXEC SQL FOR :array_size 
	FETCH C INTO DESCRIPTOR LOCAL :descriptor_name;

      *count = sqlca.sqlerrd[2] - *count; /* fetch count */
      break;

    default:
      break;
    }

  DBUG_PRINT("output", ("count: %u; return: %d", *count, sqlca.sqlcode));
  DBUG_LEAVE();

  /* when no data is found (sqlca.sqlcode == NO_DATA_FOUND) the next sql_fetch_rows() must return *count == 0 */
  return sqlca.sqlcode == NO_DATA_FOUND ? OK : sqlca.sqlcode;
}

error_t
sql_rows_processed(unsigned int *count)
{
  *count = sqlca.sqlerrd[2];

  if (sqlca.sqlcode == NO_DATA_FOUND)
    {
      sqlca.sqlcode = OK;
    }

  return sqlca.sqlcode;
}

error_t
sql_close_cursor(void)
{
  DBUG_ENTER("sql_close_cursor");

  EXEC SQL CLOSE C;

  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

error_t
sql_deallocate_descriptor(descriptor_name)
EXEC SQL BEGIN DECLARE SECTION;
const char *descriptor_name;
EXEC SQL VAR descriptor_name IS STRING;
EXEC SQL END DECLARE SECTION;
{
  DBUG_ENTER("sql_deallocate_descriptor");
  DBUG_PRINT("input", ("descriptor_name: %s", descriptor_name));

  EXEC SQL DEALLOCATE DESCRIPTOR LOCAL :descriptor_name;
      
  DBUG_PRINT("output", ("return: %d", sqlca.sqlcode));
  DBUG_LEAVE();

  return sqlca.sqlcode;
}

void
sql_error(unsigned int *length, char **msg)
{
  *length = (unsigned int) sqlca.sqlerrm.sqlerrml;
  *msg = (char *) sqlca.sqlerrm.sqlerrmc;
}
